<?php
/**
 * ChunkShield Code Validator
 * 
 * This class provides comprehensive validation and syntax checking 
 * for PHP code generated by ChunkShield.
 */

class CodeValidator {
    // Track validation results
    private $errors = [];
    private $warnings = [];
    private $passed = false;
    private $lastFile = '';
    private $lastCode = '';
    
    // Validation levels
    const LEVEL_SYNTAX = 1;       // Basic syntax checking
    const LEVEL_STRUCTURE = 2;    // Check code structure
    const LEVEL_SECURITY = 3;     // Include security checks
    const LEVEL_COMPATIBILITY = 4; // Check compatibility issues
    
    /**
     * Constructor
     */
    public function __construct() {
        // Initialize validator
    }
    
    /**
     * Validate PHP code
     * 
     * @param string $code PHP code to validate
     * @param int $level Validation level
     * @return bool True if validation passed
     */
    public function validateCode($code, $level = self::LEVEL_SYNTAX) {
        // Reset validation state
        $this->errors = [];
        $this->warnings = [];
        $this->passed = false;
        $this->lastCode = $code;
        $this->lastFile = '';
        
        // Level 1: Basic syntax check
        if (!$this->checkSyntax($code)) {
            return false;
        }
        
        // If only basic syntax check requested, we're done
        if ($level <= self::LEVEL_SYNTAX) {
            $this->passed = true;
            return true;
        }
        
        // Level 2: Code structure check
        if (!$this->checkCodeStructure($code)) {
            return false;
        }
        
        if ($level <= self::LEVEL_STRUCTURE) {
            $this->passed = true;
            return true;
        }
        
        // Level 3: Security checks
        if (!$this->checkSecurity($code)) {
            return false;
        }
        
        if ($level <= self::LEVEL_SECURITY) {
            $this->passed = true;
            return true;
        }
        
        // Level 4: Compatibility checks
        if (!$this->checkCompatibility($code)) {
            return false;
        }
        
        $this->passed = true;
        return true;
    }
    
    /**
     * Validate a PHP file
     * 
     * @param string $file Path to the PHP file
     * @param int $level Validation level
     * @return bool True if validation passed
     */
    public function validateFile($file, $level = self::LEVEL_SYNTAX) {
        if (!file_exists($file)) {
            $this->errors[] = "File not found: $file";
            return false;
        }
        
        $this->lastFile = $file;
        return $this->validateCode(file_get_contents($file), $level);
    }
    
    /**
     * Check PHP syntax
     * 
     * @param string $code PHP code to check
     * @return bool True if syntax is valid
     */
    private function checkSyntax($code) {
        // Improved version with direct syntax validation
        try {
            // Use PHP's built-in parser first
            $tokens = @token_get_all($code);
            
            // Fallback to PHP lint if tokenizer didn't throw an error
            // Create a temporary file for syntax checking
            $tempFile = tempnam(sys_get_temp_dir(), 'phpcheck_');
            file_put_contents($tempFile, $code);
            
            // Use PHP's lint feature (php -l)
            $output = [];
            $returnVar = 0;
            exec("php -l " . escapeshellarg($tempFile) . " 2>&1", $output, $returnVar);
            
            // Clean up temp file
            @unlink($tempFile);
            
            // Check results
            if ($returnVar !== 0) {
                // Extract error message
                $errorMsg = implode("\n", $output);
                $errorMsg = preg_replace('/in ' . preg_quote($tempFile, '/') . ' /', '', $errorMsg);
                $this->errors[] = "Syntax error: " . $errorMsg;
                return false;
            }
            
            return true;
        } catch (\ParseError $e) {
            // Parse error in token_get_all
            if (isset($tempFile) && file_exists($tempFile)) {
                @unlink($tempFile);
            }
            
            // Report parse error
            $this->errors[] = "Syntax error: " . $e->getMessage();
            return false;
        } catch (\Exception $e) {
            // Clean up temp file if it exists
            if (isset($tempFile) && file_exists($tempFile)) {
                @unlink($tempFile);
            }
            
            // Report any other exception
            $this->errors[] = "Error validating code: " . $e->getMessage();
            return false;
        }
    }
    
    /**
     * Check code structure (matching brackets, quotes, etc.)
     * 
     * @param string $code PHP code to check
     * @return bool True if structure is valid
     */
    private function checkCodeStructure($code) {
        $valid = true;
        
        // Check for missing PHP tags
        if (strpos($code, '<?php') === false) {
            $this->warnings[] = "Missing PHP opening tag (<?php)";
        }
        
        // Check for unmatched string quotes
        if (!$this->checkStringQuotes($code)) {
            $valid = false;
        }
        
        // Check for unmatched brackets
        if (!$this->checkBrackets($code)) {
            $valid = false;
        }
        
        // Check for unmatched PHP tags
        if (!$this->checkPHPTags($code)) {
            $valid = false;
        }
        
        return $valid;
    }
    
    /**
     * Check for unmatched string quotes
     * 
     * @param string $code PHP code to check
     * @return bool True if all quotes are matched
     */
    private function checkStringQuotes($code) {
        $valid = true;
        $lines = explode("\n", $code);
        $inSingleQuote = false;
        $inDoubleQuote = false;
        $escaped = false;
        
        foreach ($lines as $lineNum => $line) {
            for ($i = 0; $i < strlen($line); $i++) {
                $char = $line[$i];
                
                if ($escaped) {
                    $escaped = false;
                    continue;
                }
                
                if ($char === '\\') {
                    $escaped = true;
                    continue;
                }
                
                if ($inSingleQuote) {
                    if ($char === "'") {
                        $inSingleQuote = false;
                    }
                } else if ($inDoubleQuote) {
                    if ($char === '"') {
                        $inDoubleQuote = false;
                    }
                } else {
                    if ($char === "'") {
                        $inSingleQuote = true;
                    } else if ($char === '"') {
                        $inDoubleQuote = true;
                    }
                }
            }
            
            // Reset escape flag at end of line
            $escaped = false;
        }
        
        if ($inSingleQuote) {
            $this->errors[] = "Unmatched single quote (')";
            $valid = false;
        }
        
        if ($inDoubleQuote) {
            $this->errors[] = "Unmatched double quote (\")";
            $valid = false;
        }
        
        return $valid;
    }
    
    /**
     * Check for unmatched brackets
     * 
     * @param string $code PHP code to check
     * @return bool True if all brackets are matched
     */
    private function checkBrackets($code) {
        $valid = true;
        $stack = [];
        $brackets = [
            '(' => ')',
            '[' => ']',
            '{' => '}'
        ];
        
        // Strip strings and comments to avoid false positives
        $cleanCode = $this->stripStringsAndComments($code);
        
        for ($i = 0; $i < strlen($cleanCode); $i++) {
            $char = $cleanCode[$i];
            
            if (in_array($char, array_keys($brackets))) {
                array_push($stack, $char);
            } else if (in_array($char, array_values($brackets))) {
                if (empty($stack)) {
                    $this->errors[] = "Extra closing bracket: $char";
                    $valid = false;
                    continue;
                }
                
                $lastBracket = array_pop($stack);
                $expectedClosing = $brackets[$lastBracket] ?? null;
                
                if ($expectedClosing !== $char) {
                    $this->errors[] = "Mismatched brackets: expected $expectedClosing but found $char";
                    $valid = false;
                }
            }
        }
        
        if (!empty($stack)) {
            $remaining = count($stack);
            $lastBracket = end($stack);
            $expectedClosing = $brackets[$lastBracket] ?? '?';
            $this->errors[] = "Missing $remaining closing bracket(s). Expected: $expectedClosing";
            $valid = false;
        }
        
        return $valid;
    }
    
    /**
     * Check for unmatched PHP tags
     * 
     * @param string $code PHP code to check
     * @return bool True if all PHP tags are matched
     */
    private function checkPHPTags($code) {
        $valid = true;
        $openTags = preg_match_all('/<\?(?:php)?/i', $code, $matches);
        $closeTags = preg_match_all('/\?>/i', $code, $matches);
        
        if ($openTags > $closeTags) {
            $this->warnings[] = "Missing PHP closing tag(s). Found $openTags opening tags but only $closeTags closing tags.";
        } else if ($closeTags > $openTags) {
            $this->errors[] = "Extra PHP closing tag(s). Found $closeTags closing tags but only $openTags opening tags.";
            $valid = false;
        }
        
        return $valid;
    }
    
    /**
     * Check for security issues
     * 
     * @param string $code PHP code to check
     * @return bool True if no security issues found
     */
    private function checkSecurity($code) {
        $valid = true;
        
        // Check for dangerous functions
        $dangerousFunctions = [
            'eval' => false,         // Not always bad in our context, just warn
            'exec' => true,
            'shell_exec' => true,
            'system' => true,
            'passthru' => true,
            'popen' => true,
            'proc_open' => true,
            'assert' => true,
            'create_function' => true
        ];
        
        foreach ($dangerousFunctions as $func => $isCritical) {
            if (preg_match('/\b' . preg_quote($func, '/') . '\s*\(/i', $code)) {
                if ($isCritical) {
                    $this->errors[] = "Security issue: Using dangerous function '$func'";
                    $valid = false;
                } else {
                    $this->warnings[] = "Potential security issue: Using function '$func'. Use with caution.";
                }
            }
        }
        
        // Check for SQL injection vulnerabilities
        if (preg_match('/mysql_query|mysqli_query|->query/i', $code)) {
            if (preg_match('/\$_GET|\$_POST|\$_REQUEST|\$_COOKIE/i', $code)) {
                $this->warnings[] = "Potential SQL injection: Using user input with database queries";
            }
        }
        
        return $valid;
    }
    
    /**
     * Check for compatibility issues
     * 
     * @param string $code PHP code to check
     * @return bool True if no compatibility issues found
     */
    private function checkCompatibility($code) {
        $valid = true;
        
        // Check for PHP 7+ array shorthand syntax
        if (preg_match('/\[\s*(?:\s*[\'"][^\'"]+[\'"]|\s*[0-9]+)?\s*=>/i', $code)) {
            $this->warnings[] = "Compatibility issue: Array shorthand syntax (PHP 5.4+)";
        }
        
        // Check for PHP 7 features
        if (preg_match('/\bfn\s*\(/i', $code)) {
            $this->warnings[] = "Compatibility issue: Arrow functions (PHP 7.4+)";
        }
        
        if (preg_match('/\?\?/i', $code)) {
            $this->warnings[] = "Compatibility issue: Null coalescing operator (PHP 7+)";
        }
        
        if (preg_match('/::class\b/i', $code)) {
            $this->warnings[] = "Compatibility issue: ::class keyword (PHP 5.5+)";
        }
        
        return $valid;
    }
    
    /**
     * Strip strings and comments from code
     * 
     * @param string $code PHP code
     * @return string Code with strings and comments removed
     */
    private function stripStringsAndComments($code) {
        // Remove single line comments
        $code = preg_replace('!//.+$!m', '', $code);
        
        // Remove multi-line comments
        $code = preg_replace('!/\*.*?\*/!s', '', $code);
        
        // Remove single-quoted strings
        $code = preg_replace("!'(?:\\\\.|[^'\\\\])*'!s", "''", $code);
        
        // Remove double-quoted strings
        $code = preg_replace('!"(?:\\\\.|[^"\\\\])*"!s', '""', $code);
        
        return $code;
    }
    
    /**
     * Force add an error (for testing purposes)
     * 
     * @param string $error Error message to add
     */
    public function forceAddError($error) {
        $this->errors[] = $error;
        $this->passed = false;
    }
    
    /**
     * Get all errors
     * 
     * @return array Array of error messages
     */
    public function getErrors() {
        return $this->errors;
    }
    
    /**
     * Get all warnings
     * 
     * @return array Array of warning messages
     */
    public function getWarnings() {
        return $this->warnings;
    }
    
    /**
     * Get validation status
     * 
     * @return bool True if validation passed
     */
    public function isPassed() {
        return $this->passed;
    }
    
    /**
     * Get validation results as array
     * 
     * @return array Validation results
     */
    public function getResults() {
        return [
            'passed' => $this->passed,
            'errors' => $this->errors,
            'warnings' => $this->warnings,
            'file' => $this->lastFile,
            'has_errors' => !empty($this->errors),
            'has_warnings' => !empty($this->warnings),
            'error_count' => count($this->errors),
            'warning_count' => count($this->warnings)
        ];
    }
    
    /**
     * Get validation results as formatted string
     * 
     * @param bool $colorize Whether to use ANSI color codes
     * @return string Formatted validation results
     */
    public function getFormattedResults($colorize = true) {
        $result = "";
        
        if ($this->lastFile) {
            $result .= "File: " . $this->lastFile . "\n";
        }
        
        if ($this->passed) {
            $passedText = "PASSED";
            $result .= $colorize ? "\033[32m" . $passedText . "\033[0m\n" : $passedText . "\n";
        } else {
            $failedText = "FAILED";
            $result .= $colorize ? "\033[31m" . $failedText . "\033[0m\n" : $failedText . "\n";
        }
        
        if (!empty($this->errors)) {
            $result .= "Errors:\n";
            foreach ($this->errors as $error) {
                $result .= $colorize ? "\033[31m - " . $error . "\033[0m\n" : " - " . $error . "\n";
            }
        }
        
        if (!empty($this->warnings)) {
            $result .= "Warnings:\n";
            foreach ($this->warnings as $warning) {
                $result .= $colorize ? "\033[33m - " . $warning . "\033[0m\n" : " - " . $warning . "\n";
            }
        }
        
        return $result;
    }
}